Function string iTRACK_getTrackDataById(int trackId)
Begin
	Switch(trackId)
		case 0: //Tema 1, no 0.
			return "2.440:" + gamePad.PAD_A + ":0:0:0:0:0,4.280:" + gamePad.PAD_R + ":0:0:0:0:0,6.127:" + gamePad.PAD_B + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:0:0:0:0,27.008:" + gamePad.PAD_R + ":0:0:0:0:0,28.108:" + gamePad.PAD_B + ":0:0:0:0:0,34.518:" + gamePad.PAD_A + ":0:1:0:0:0";
		end
		case 1: //tema 2, no 1.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 2: //tema 3, no 2.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 3: //tema 4, no 3.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 4: //tema 5, no 4.
			return "2.440:" + gamePad.PAD_A + ":0:0:0:0:0,4.280:" + gamePad.PAD_R + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_B + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 5: //tema 5, no 4.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 6: //tema 5, no 4.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 7: //tema 5, no 4.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
		case 8: //tema 5, no 4.
			return "2.440:" + gamePad.PAD_LEFT + ":0:0:0:0:0,4.280:" + gamePad.PAD_LEFT + ":0:0:0:0:0,6.127:" + gamePad.PAD_LEFT + ":0:0:0:0:0,8.972:" + gamePad.PAD_LEFT + ":0:0:0:0:0,10.805:" + gamePad.PAD_LEFT + ":0:0:0:0:0,12.634:" + gamePad.PAD_LEFT + ":0:0:0:0:0,14.510:" + gamePad.PAD_LEFT + ":0:0:0:0:0,20.357:" + gamePad.PAD_LEFT + ":0:0:0:0:0,22.178:" + gamePad.PAD_LEFT + ":0:0:0:0:0,24.008:" + gamePad.PAD_LEFT + ":0:1:0:0:0";
		end
	End
End

Function iTRACK_setTracksCollection()
Private
Begin

	//Inicializamos la lista de canciones

	/*
	BTTrackCollection[0]._Name = "Cool Chiptune";
	BTTrackCollection[0]._Author = "Katie Cadet";
	BTTrackCollection[0]._Level = 1;
	BTTrackCollection[0]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[0]._TotalChords = 14;
	BTTrackCollection[0]._trackId = gi_MusicTRK01;
	
	BTTrackCollection[1]._Name = "Bit loader";
	BTTrackCollection[1]._Author = "KeiDash";
	BTTrackCollection[1]._Level = 1;
	BTTrackCollection[1]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[1]._TotalChords = 10;
	BTTrackCollection[1]._trackId = gi_MusicTRK02;
	
	BTTrackCollection[2]._Name = "Chemical 16";
	BTTrackCollection[2]._Author = "?¿?¿";
	BTTrackCollection[2]._Level = 0;
	BTTrackCollection[2]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[2]._TotalChords = 10;
	BTTrackCollection[2]._trackId = gi_MusicTRK03;
	
	BTTrackCollection[3]._Name = "Smoking' Crack";
	BTTrackCollection[3]._Author = "?¿?¿";
	BTTrackCollection[3]._Level = 2;
	BTTrackCollection[3]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[3]._TotalChords = 10;
	BTTrackCollection[3]._trackId = gi_MusicTRK04;
	
	BTTrackCollection[4]._Name = "Sexy Bit 2!!";
	BTTrackCollection[4]._Author = "Unknow";
	BTTrackCollection[4]._Level = "Medium";
	BTTrackCollection[4]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[4]._TotalChords = 10;
	BTTrackCollection[4]._trackId = gi_MusicTRK05;
	
	BTTrackCollection[5]._Name = "The Dim Dungeon";
	BTTrackCollection[5]._Author = "?¿?¿";
	BTTrackCollection[5]._Level = 1;
	BTTrackCollection[5]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[5]._TotalChords = 10;
	BTTrackCollection[5]._trackId = gi_MusicTRK06;
	
	BTTrackCollection[6]._Name = "The Radiz Point";
	BTTrackCollection[6]._Author = "?¿?¿";
	BTTrackCollection[6]._Level = 1;
	BTTrackCollection[6]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[6]._TotalChords = 10;
	BTTrackCollection[6]._trackId = gi_MusicTRK07;
	
	BTTrackCollection[7]._Name = "Viral Legacy";
	BTTrackCollection[7]._Author = "####";
	BTTrackCollection[7]._Level = 1;
	BTTrackCollection[7]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[7]._TotalChords = 10;
	BTTrackCollection[7]._trackId = gi_MusicTRK08;
	
	BTTrackCollection[8]._Name = "The Dim Dungeon 2";
	BTTrackCollection[8]._Author = "?¿?¿";
	BTTrackCollection[8]._Level = 1;
	BTTrackCollection[8]._TiempoEspera = TimeToMiliseconds("6.130");
	BTTrackCollection[8]._TotalChords = 10;
	BTTrackCollection[8]._trackId = gi_MusicTRK09;
	*/
End

/*
* Descripcion: 	Función que carga las notas musicales de las canciones en memoria, dentro del array de canciones principal.
* Parametros:	<enable> de tipo byte (true/false) que muestra u oculta el
*				mensaje de 'loading'
*/
Function iTRACK_setTrackDemo()
Private
	byte i = 0;
Begin

	FROM i = 0 TO (NTRACKS - 1) STEP 1;
		iTRACK_setTrack(i);

		Repeat
			frame;
		Until(gi_TrackLoaded == true)
		
		gi_TrackLoaded = false;
		
		frame;
	End
End

/*
* Descripcion: 	Este proceso es el encargado de cargar los datos de una cancion
*				concreta.
* Parametros:	
*/
Process iTRACK_setTrack(byte trackId)
Private
	string strOut;
	int n = 0;
	int sn = 0;
	int i = 0;
	string bttOutput[6];
Begin
	
	/*
	switch(trackId)
		case 0:
			set_Track_01();
		end
		case 1:
		end
	end
	*/
	
	/********************************************************
	if(BTTrackCollection[trackId]._Loaded) 
		return; 
	end
	
	frame;
	
	strOut = iTRACK_getTrackDataById(trackId);
	
	//Si el string obtenido es 0 o menor, es que no se devolvi? nada, por lo que salimos.
	if(len(strOut) <= 0) return; end

	//Hacemos split para obtener todos los registros dentro del puntero de strings, según la canción
	n = Split(",", strOut, &gs_ArrayStrDataTrack01, LEN(strOut));

	if (n > 0)
		for(i = 0; i < n; i++)
		
			sn = Split(":", gs_ArrayStrDataTrack01[i], &bttOutput, LEN(gs_ArrayStrDataTrack01[i]));

			if(sn > 0)
				
				BTTrackCollection[trackId]._Chords[i]._Tiempo 		= TimeToMiliseconds(bttOutput[0]) + BTTrackCollection[trackId]._TiempoEspera;
				BTTrackCollection[trackId]._Chords[i]._Nota 		= atoi(bttOutput[1]);
				BTTrackCollection[trackId]._Chords[i]._Freeze 		= atoi(bttOutput[2]);
				BTTrackCollection[trackId]._Chords[i]._Last 		= atoi(bttOutput[3]);
				BTTrackCollection[trackId]._Chords[i]._Father 		= atoi(bttOutput[4]);
				BTTrackCollection[trackId]._Chords[i]._Son 			= atoi(bttOutput[5]);
				BTTrackCollection[trackId]._Chords[i]._SonThrowed 	= 0;
				BTTrackCollection[trackId]._Chords[i]._Speed 		= 2;
				
			end
			
			bttOutput[1] = "";
			bttOutput[2] = "";
			bttOutput[3] = "";
			bttOutput[4] = "";
			bttOutput[5] = "";
			
			frame;
		end
	end
	********************************************************/
	
	//ESTABLECEMOS EL TIEMPO MINIMO DE CONGELACION
	set_FreezingTime(trackId);
	
	//ESTABLECEMOS LOS FREEZE
	iTRACK_setSleeps(trackId);
	
	//OBTENEMOS LOS ID's DE TODOS LOS PROCESOS
	iTRACK_linkFatherProcIds(trackId);

	//ASOCIAMOS HIJOS CON PADRES
	iTRACK_linkSonsToFathers(trackId);

	//MARCAMOS LA CANCION COMO CARGADA
	//BTTrackCollection[trackId]._Loaded = true;
	
OnExit
	gi_TrackLoaded = true;
End


/**
  * @desc	Establece el tiempo minimo de espera, para determinar si la nota debe ser congelada o no.
  * @param 	byte $trackId - Identificador de la cancion
  * @return void - no retorno
*/
Function set_FreezingTime(byte trackId)
Private
Begin
	tTiempoFreeze = TrackArray[0][_TIEMPO] + ((tTiempoEspera * 4) + TimeToMiliseconds("3.000"));
	
	//BTTrackCollection[trackId]._TiempoFreeze = BTTrackCollection[trackId]._Chords[0]._Tiempo + ((BTTrackCollection[trackId]._TiempoEspera * 4) + TimeToMiliseconds("3.000"));
End


/**
  * @desc	Proceso que calcula los tiempos de espera entre notas, para indicar si la nota
  			queda congelada (Freeze) esperando a que la llame posteriormente un padre.
  * @param 	byte $trackId - Identificador de la cancion
  * @return void - no retorno
  * @notes	Freeze se establece en base a un calculo. Dicho calculo, se establece en base a
  			al propio tiempo de la nota Nº 0, el tiempo de espera de la canción * 4 y + 3 segundos de delay.
			Si el tiempo de cada nota, no supera el tiempo minimo, no se congela. En caso contrario,
			se congela y se establece el % en el que el hijo será llamado.
*/
Function iTRACK_setSleeps(byte trackId)
Private
	byte i = 0;
Begin

	for(i = 0; i < tTotalChords; i++)
	
		if((TrackArray[i][_TIEMPO]) >= tTiempoFreeze)
			TrackArray[i][_FREEZE] = 1;
			if(i > 0)
				if((TrackArray[i][_TIEMPO] - TrackArray[i-1][_TIEMPO]) > iTIME_get_PercentToShowSon(TrackArray[i][_SPEED]))
					TrackArray[i][_SONTHROWEDP] = 20;
				else
					TrackArray[i][_SONTHROWEDP] = 60;
				end
			end
		end
		
		frame;
	end
	
	/*
	for(i = 0; i < BTTrackCollection[trackId]._TotalChords; i++)
	
		if((BTTrackCollection[trackId]._Chords[i]._Tiempo) >= BTTrackCollection[trackId]._TiempoFreeze)
			BTTrackCollection[trackId]._Chords[i]._Freeze = 1;
			if(i > 0)
				if((BTTrackCollection[trackId]._Chords[i]._Tiempo - BTTrackCollection[trackId]._Chords[i-1]._Tiempo) > iTIME_get_PercentToShowSon(BTTrackCollection[trackId]._Chords[i]._Speed))
					BTTrackCollection[trackId]._Chords[i]._SonThrowPercent = 20;
				else
					BTTrackCollection[trackId]._Chords[i]._SonThrowPercent = 60;
				end
			end
		end
		
		frame;
	end
	*/
	
End

/*TRATAMIENTO DE LAS NOTAS MUSICALES JUNTO CON EL ARRAY Y SUS PROPIEDADES*/
Function iTRACK_linkFatherProcIds(byte trackId)
Private
	byte c = 0;
Begin
	
	for(c = 0; c < tTotalChords; c++)
		
		iGAME_WaitingForDisplay(trackId, TrackArray[c][_TIEMPO], TrackArray[c][_NOTA], c);
		
		SIGNAL(ID.SON, S_SLEEP);
		
		TrackArray[c][_FATHER] = ID.SON;
		
		frame;
	End
	
	/*
	For(c = 0; c < BTTrackCollection[trackId]._TotalChords; c++)
		
		iGAME_WaitingForDisplay(trackId, BTTrackCollection[trackId]._Chords[c]._Tiempo, BTTrackCollection[trackId]._Chords[c]._Nota, c);
		SIGNAL(ID.SON, S_SLEEP);
		BTTrackCollection[trackId]._Chords[c]._Father = ID.SON;
		//say("PADRE: " + BTTrackCollection[trackId]._Chords[c]._Father);
		frame;
	End
	*/
	
End

Function iTRACK_linkSonsToFathers(byte trackId)
Private
	byte c = 0;
	byte linkIndex = 0;
Begin

	for(c = 0; c < tTotalChords; c++)
	
		if (TrackArray[c][_FREEZE] == 1)
			TrackArray[linkIndex][_SON] = TrackArray[c][_FATHER];
			linkIndex++;
		end

		frame;
	end
	
	/*
	
	for(c = 0; c < BTTrackCollection[trackId]._TotalChords; c++)
	
		if (BTTrackCollection[trackId]._Chords[c]._Freeze == 1)
			BTTrackCollection[trackId]._Chords[linkIndex]._Son = BTTrackCollection[trackId]._Chords[c]._Father;
			linkIndex++;
		end

		frame;
	end
	*/
End

//Process iTRACK_launchFathers(byte trackId)
Process iTRACK_launchFathers()
Private
	byte c = 0;
Begin

	for(c = 0; c < 	tTotalChords; c++)
	
		if(TrackArray[c][_FREEZE] == 0)
			SIGNAL(TrackArray[c][_FATHER], S_WAKEUP);
		end

		frame;
	end
	
	/*
	for(c = 0; c < 	BTTrackCollection[trackId]._TotalChords; c++)
	
		if(BTTrackCollection[trackId]._Chords[c]._Freeze == 0)
			//say("Se lanza: " + BTTrackCollection[trackId]._Chords[c]._Father);
			SIGNAL(BTTrackCollection[trackId]._Chords[c]._Father, S_WAKEUP);
		end

		frame;
	end	
	*/
End

